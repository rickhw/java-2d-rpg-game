# 遊戲循環 (Game Loop) 運作原理

遊戲循環是所有即時遊戲的核心，它是一個不斷運行的循環，負責處理遊戲的輸入、更新遊戲世界的狀態，並將結果渲染到螢幕上。在 `GamePanel.java` 的 `run()` 方法中，我們可以看到這個核心機制的實現。

您的專案中包含了兩種常見的遊戲循環實現方式，目前使用的是第二種（Delta/Accumulator），它比第一種（Fixed Sleep）更為先進和穩定。

---

## 方法一：固定休眠法 (Fixed Sleep)

這是遊戲循環最基礎的實現方式，在您的程式碼中被註解起來的部分就是這種方法。

### 原理

它的邏輯非常直觀：

1.  **設定目標 FPS**：首先定義一個目標幀率，例如 60 FPS。
2.  **計算每幀時間**：計算出每一幀應該花費多少時間（`drawInterval`），例如 `1/60` 秒。
3.  **執行與休眠**：在循環中，執行一次「更新」和「渲染」，然後計算該次循環花費了多少時間。用「每幀應花費時間」減去「實際花費時間」，得出需要「休眠」多久，然後讓執行緒（Thread）`sleep()` 這段時間。

### 圖示

```
[ 開始循環 ]
     |
     v
[ 1. 更新遊戲狀態 (update) ]
     |
     v
[ 2. 請求畫面重繪 (repaint) ]
     |
     v
[ 3. 計算本次循環耗時 ]
     |
     v
[ 4. 計算剩餘時間 (應有時間 - 耗時) ]
     |
     v
[ 5. 執行緒休眠剩餘時間 (sleep) ]
     |
     v
[ 回到循環開頭 ]
```

### 優缺點

-   **優點**：簡單易懂，容易實現。
-   **缺點**：如果某次 `update` 或 `repaint` 的時間超過了 `drawInterval`，`sleep` 時間會是負數或零，導致下一幀立刻開始，造成 FPS 下降和不穩定。這種不穩定會影響遊戲的流暢度。

---

## 方法二：Delta Time / 累加器法 (Delta/Accumulator)

這是您目前正在使用的、更為健壯的遊戲循環方法。它能更好地處理效能波動，將**遊戲邏輯更新**與**畫面渲染**的頻率進行解耦。

### 原理

1.  **設定目標 FPS**：和方法一相同，計算出理論上每幀的間隔時間 `drawInterval`。
2.  **宣告累加器 `delta`**：宣告一個 `delta` 變數，初始值為 0。這個變數將用來累積「**過去這段時間，理論上應該要執行幾次更新**」。
3.  **累積時間**：在每一次循環中，計算自上次循環到現在經過了多少時間（`currentTime - lastTime`）。
4.  **更新 `delta`**：將經過的時間除以 `drawInterval`，加到 `delta` 上。例如，如果經過的時間剛好等於 `drawInterval`，`delta` 就會增加 1.0。如果經過的時間是 `drawInterval` 的一半，`delta` 就增加 0.5。
5.  **檢查 `delta`**：一旦 `delta` 的值大於或等於 1，就代表**至少累積了一個 `update` 週期的時間**。這時就執行一次 `update()` 和 `repaint()`，並將 `delta` 減 1。
6.  **處理延遲**：如果系統發生延遲（例如某次循環耗時是 `drawInterval` 的 2.5 倍），`delta` 就會累積到 2.5。`while(delta >= 1)` 的結構（在您的程式碼中是 `if`）會確保 `update()` 被執行兩次，以「追趕」上遊戲應有的進度，然後才進行渲染。

### 圖示

```
[ 開始循環 ]
     |
     v
[ 1. 計算自上次循環至今的耗時 ]
     |
     v
[ 2. delta += 耗時 / 每幀理論時間 ]
     |
     v
/--[ delta >= 1 ? ]--\
|        (Yes)        |
|          |          | (No)
|          v          |
| [ 3. 更新狀態 (update) ] |
| [ 4. 請求重繪 (repaint) ] |
| [ 5. delta-- ]      |
|          |          |
\----<----[----------]-->[ 回到循環開頭 ]
```

### 優缺點

-   **優點**：
    -   **更新頻率穩定**：即使渲染速度（FPS）下降，遊戲邏輯的更新速度也能保持相對穩定，讓遊戲行為（如物理、移動）感覺更一致。
    -   **處理效能抖動**：能更好地應對系統的短暫延遲，透過追趕 `update` 次數來彌補失去的時間。
-   **缺點**：比第一種方法稍微複雜，較難第一時間理解。
