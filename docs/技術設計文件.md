# M/A Legend - 技術設計文件 (Technical Design Document)

## 1. 系統架構概述

### 1.1 整體架構
M/A Legend採用分層架構設計，基於Java Swing框架構建的2D遊戲引擎。系統採用組件化設計，各個子系統職責明確，耦合度低，便於維護和擴展。

```
┌─────────────────────────────────────────┐
│                Main                     │
│            (應用程式入口)                 │
└─────────────┬───────────────────────────┘
              │
┌─────────────▼───────────────────────────┐
│              GamePanel                  │
│           (遊戲核心引擎)                  │
│  ┌─────────────────────────────────────┐ │
│  │         Game Loop                   │ │
│  │      (60 FPS 遊戲循環)               │ │
│  └─────────────────────────────────────┘ │
└─────────────┬───────────────────────────┘
              │
    ┌─────────┼─────────┐
    │         │         │
┌───▼───┐ ┌──▼──┐ ┌────▼────┐
│Entity │ │Tile │ │ System  │
│ 系統  │ │系統 │ │  系統   │
└───────┘ └─────┘ └─────────┘
```

### 1.2 核心設計原則
- **單一職責原則**: 每個類別都有明確的單一職責
- **開放封閉原則**: 對擴展開放，對修改封閉
- **組合優於繼承**: 使用組合關係降低耦合度
- **狀態機模式**: 使用狀態機管理遊戲不同狀態

## 2. 核心系統設計

### 2.1 遊戲引擎核心 (GamePanel)

#### 2.1.1 類別結構
```java
public class GamePanel extends JPanel implements Runnable {
    // 遊戲設定
    final int originalTileSize = 16;
    final int scale = 4;
    public final int tileSize = 64; // 16 * 4
    
    // 系統組件
    public TileManager tileManager;
    public KeyHandler keyHandler;
    public CollisionChecker collisionChecker;
    public UI ui;
    public Player player;
    
    // 遊戲循環
    Thread gameThread;
    public final int FPS = 60;
}
```

#### 2.1.2 遊戲循環實現
採用Delta Time累加器方法，確保遊戲邏輯更新頻率的穩定性：

```java
public void run() {
    double drawInterval = 1000000000/FPS; // 16.67ms per frame
    double delta = 0;
    long lastTime = System.nanoTime();
    long currentTime;
    
    while(gameThread != null) {
        currentTime = System.nanoTime();
        delta += (currentTime - lastTime) / drawInterval;
        lastTime = currentTime;
        
        if(delta >= 1) {
            update();
            repaint();
            delta--;
        }
    }
}
```

#### 2.1.3 渲染管線
嚴格按照Z-order進行分層渲染：
1. **背景層**: 地圖瓦片 (TileManager)
2. **物件層**: 遊戲物件 (Objects)
3. **實體層**: 玩家和NPC (Entities)
4. **效果層**: 粒子效果 (Particles)
5. **UI層**: 使用者介面 (UI)

### 2.2 實體系統 (Entity System)

#### 2.2.1 實體基礎類別
```java
public abstract class Entity {
    // 世界座標
    public int worldX, worldY;
    
    // 移動屬性
    public int speed;
    public String direction = "down";
    
    // 碰撞檢測
    public Rectangle solidArea;
    public boolean collisionOn = false;
    
    // 生命週期方法
    public abstract void update();
    public abstract void draw(Graphics2D g2);
}
```

#### 2.2.2 玩家系統 (Player)
```java
public class Player extends Entity {
    // 螢幕座標 (攝影機中心)
    public final int screenX;
    public final int screenY;
    
    // 玩家屬性
    public int level;
    public int life, maxLife;
    public int mana, maxMana;
    public int exp, nextLevelExp;
    
    // 裝備系統
    public Entity currentWeapon;
    public Entity currentShield;
    
    // 背包系統
    public ArrayList<Entity> inventory;
}
```

#### 2.2.3 怪物AI系統
```java
public class Monster extends Entity {
    public void setAction() {
        // AI行為邏輯
        if(onPath) {
            // 尋路追蹤玩家
            searchPath(getGoalCol(gp.player), getGoalRow(gp.player));
        } else {
            // 隨機移動
            actionLockCounter++;
            if(actionLockCounter == 120) {
                Random random = new Random();
                int i = random.nextInt(100) + 1;
                if(i <= 25) direction = "up";
                // ... 其他方向
                actionLockCounter = 0;
            }
        }
    }
}
```

### 2.3 瓦片系統 (Tile System)

#### 2.3.1 瓦片管理器
```java
public class TileManager {
    GamePanel gp;
    public Tile[] tile;
    public int mapTileNum[][][]; // [map][col][row]
    
    public void loadMap(String filePath, int map) {
        // 從文字檔載入地圖資料
        // 格式: 數字代表不同瓦片類型
    }
    
    public void draw(Graphics2D g2) {
        // 只渲染攝影機可見範圍內的瓦片
        // 優化渲染效能
    }
}
```

#### 2.3.2 地圖格式
```
地圖檔案格式 (.txt):
0 0 0 1 1 1 0 0 0
0 1 1 1 2 1 1 1 0
0 1 2 2 2 2 2 1 0
1 1 2 3 3 3 2 1 1
1 2 2 3 4 3 2 2 1

數字對應:
0 = 草地
1 = 樹木 (有碰撞)
2 = 石頭路徑
3 = 水面 (有碰撞)
4 = 特殊瓦片
```

### 2.4 碰撞檢測系統

#### 2.4.1 碰撞檢測器
```java
public class CollisionChecker {
    public void checkTile(Entity entity) {
        // 計算實體四個角的瓦片座標
        int entityLeftWorldX = entity.worldX + entity.solidArea.x;
        int entityRightWorldX = entity.worldX + entity.solidArea.x + entity.solidArea.width;
        int entityTopWorldY = entity.worldY + entity.solidArea.y;
        int entityBottomWorldY = entity.worldY + entity.solidArea.y + entity.solidArea.height;
        
        // 檢查移動後的位置是否與固體瓦片碰撞
        // 根據移動方向檢查對應的瓦片
    }
    
    public int checkObject(Entity entity, boolean player) {
        // 檢查與物件的碰撞
        // 返回碰撞物件的索引，999表示無碰撞
    }
    
    public int checkEntity(Entity entity, Entity[][] target) {
        // 檢查實體間的碰撞
        // 用於玩家與NPC、怪物間的碰撞檢測
    }
}
```

#### 2.4.2 碰撞優化
- **空間分割**: 只檢查攝影機可見範圍內的碰撞
- **早期退出**: 一旦檢測到碰撞立即返回
- **矩形碰撞**: 使用Rectangle.intersects()進行快速檢測

### 2.5 輸入處理系統

#### 2.5.1 鍵盤處理器
```java
public class KeyHandler implements KeyListener {
    GamePanel gp;
    public boolean upPressed, downPressed, leftPressed, rightPressed;
    public boolean enterPressed, spacePressed;
    
    // 狀態相關按鍵
    public boolean checkDrawTime = false;
    public boolean godModeOn = false;
    
    @Override
    public void keyPressed(KeyEvent e) {
        int code = e.getKeyCode();
        
        // 根據遊戲狀態處理不同按鍵
        if(gp.gameState == gp.titleState) {
            titleState(code);
        } else if(gp.gameState == gp.playState) {
            playState(code);
        }
        // ... 其他狀態
    }
}
```

#### 2.5.2 輸入映射
```
遊戲控制:
W/↑ = 向上移動
S/↓ = 向下移動  
A/← = 向左移動
D/→ = 向右移動
SPACE = 攻擊
ENTER = 互動/確認
ESC = 暫停選單

系統控制:
M = 世界地圖
V = 小地圖切換
C = 角色狀態
I = 背包
F = 全螢幕切換
```

### 2.6 音效系統

#### 2.6.1 音效管理器
```java
public class Sound {
    Clip clip;
    URL soundURL[] = new URL[30];
    
    public void setFile(int i) {
        try {
            AudioInputStream ais = AudioSystem.getAudioInputStream(soundURL[i]);
            clip = AudioSystem.getClip();
            clip.open(ais);
        } catch(Exception e) {
            e.printStackTrace();
        }
    }
    
    public void play() { clip.start(); }
    public void loop() { clip.loop(Clip.LOOP_CONTINUOUSLY); }
    public void stop() { clip.stop(); }
}
```

#### 2.6.2 音效分類
```
背景音樂 (BGM):
- 標題畫面音樂
- 世界地圖音樂  
- 地下城音樂
- Boss戰音樂

音效 (SE):
- 攻擊音效
- 受傷音效
- 撿取物品音效
- 開門音效
- 選單操作音效
```

### 2.7 UI系統

#### 2.7.1 UI管理器
```java
public class UI {
    GamePanel gp;
    Graphics2D g2;
    public Font maruMonica, purisaB;
    
    // 對話系統
    public String currentDialogue = "";
    public int charIndex = 0;
    public String combinedText = "";
    
    // 狀態顯示
    BufferedImage heart_full, heart_half, heart_blank;
    BufferedImage crystal_full, crystal_blank;
    
    public void draw(Graphics2D g2) {
        this.g2 = g2;
        
        // 根據遊戲狀態繪製不同UI
        if(gp.gameState == gp.titleState) {
            drawTitleScreen();
        } else if(gp.gameState == gp.playState) {
            drawPlayerLife();
            drawMessage();
        }
        // ... 其他狀態UI
    }
}
```

#### 2.7.2 UI組件設計
- **生命值顯示**: 心形圖示，支援半心顯示
- **魔力值顯示**: 水晶圖示顯示魔力
- **小地圖**: 即時顯示玩家位置和周圍環境
- **背包介面**: 4x5格子佈局，支援物品拖拽
- **對話框**: 支援多行文字和逐字顯示效果

### 2.8 狀態管理系統

#### 2.8.1 遊戲狀態
```java
public enum GameState {
    TITLE_STATE,      // 標題畫面
    PLAY_STATE,       // 遊戲進行
    PAUSE_STATE,      // 暫停狀態
    DIALOGUE_STATE,   // 對話狀態
    CHARACTER_STATE,  // 角色狀態畫面
    OPTIONS_STATE,    // 設定選單
    GAME_OVER_STATE,  // 遊戲結束
    TRANSITION_STATE, // 場景切換
    TRADE_STATE,      // 交易狀態
    SLEEP_STATE,      // 睡眠狀態
    MAP_STATE,        // 地圖狀態
    CUTSCENE_STATE    // 過場動畫
}
```

#### 2.8.2 狀態切換邏輯
```java
public void changeGameState(GameState newState) {
    GameState previousState = currentState;
    currentState = newState;
    
    // 狀態切換時的特殊處理
    switch(newState) {
        case PAUSE_STATE:
            music.stop();
            break;
        case PLAY_STATE:
            if(previousState == PAUSE_STATE) {
                music.play();
            }
            break;
    }
}
```

## 3. 資料結構設計

### 3.1 遊戲世界資料結構

#### 3.1.1 多維陣列設計
```java
// 多地圖支援的三維陣列
public Entity obj[][] = new Entity[maxMap][20];        // 物件
public Entity npc[][] = new Entity[maxMap][10];        // NPC
public Entity monster[][] = new Entity[maxMap][20];    // 怪物
public InteractiveTile iTile[][] = new InteractiveTile[maxMap][50]; // 互動瓦片

// 地圖瓦片資料
public int mapTileNum[][][] = new int[maxMap][maxWorldCol][maxWorldRow];
```

#### 3.1.2 實體列表管理
```java
// 動態實體管理
public ArrayList<Entity> particleList = new ArrayList<>();  // 粒子效果
public ArrayList<Entity> projectileList = new ArrayList<>(); // 投射物

// 渲染排序用的實體列表
ArrayList<Entity> entityList = new ArrayList<>();
```

### 3.2 存檔資料結構

#### 3.2.1 存檔格式
```java
public class SaveData {
    // 玩家資料
    int level, life, mana, strength, dexterity, exp, nextLevelExp;
    int coin, worldX, worldY;
    String direction;
    
    // 背包資料
    String[] itemNames = new String[gp.player.inventory.size()];
    int[] itemAmounts = new int[gp.player.inventory.size()];
    
    // 裝備資料
    int currentWeaponSlot, currentShieldSlot;
    
    // 世界狀態
    String[] mapObjectNames = new String[gp.obj[1].length];
    int[] mapObjectWorldX = new int[gp.obj[1].length];
    int[] mapObjectWorldY = new int[gp.obj[1].length];
}
```

### 3.3 配置資料結構

#### 3.3.1 遊戲設定
```java
public class Config {
    public boolean fullScreenOn = false;
    public int musicVolume = 4;
    public int seVolume = 4;
    
    public void saveConfig() {
        try {
            BufferedWriter bw = new BufferedWriter(new FileWriter("config.txt"));
            // 全螢幕設定
            if(fullScreenOn == true) {
                bw.write("On");
            } else {
                bw.write("Off");
            }
            bw.newLine();
            
            // 音量設定
            bw.write(String.valueOf(musicVolume));
            bw.newLine();
            bw.write(String.valueOf(seVolume));
            bw.newLine();
            
            bw.close();
        } catch(IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 4. 演算法設計

### 4.1 尋路演算法 (A* Pathfinding)

#### 4.1.1 A*演算法實現
```java
public class PathFinder {
    Node[][] node;
    ArrayList<Node> openList = new ArrayList<>();
    public ArrayList<Node> pathList = new ArrayList<>();
    Node startNode, goalNode, currentNode;
    boolean goalReached = false;
    int step = 0;
    
    public boolean search(int startCol, int startRow, int goalCol, int goalRow) {
        int col = startCol;
        int row = startRow;
        
        while(!goalReached && step < 500) {
            col = currentNode.col;
            row = currentRow.row;
            
            // 檢查當前節點
            currentNode.checked = true;
            openList.remove(currentNode);
            
            // 開啟上方節點
            if(row - 1 >= 0) {
                openNode(node[col][row-1]);
            }
            // 開啟左、右、下方節點...
            
            // 找到最佳節點
            int bestNodeIndex = 0;
            int bestNodefCost = 999;
            
            for(int i = 0; i < openList.size(); i++) {
                if(openList.get(i).fCost < bestNodefCost) {
                    bestNodeIndex = i;
                    bestNodefCost = openList.get(i).fCost;
                }
            }
            currentNode = openList.get(bestNodeIndex);
            
            if(currentNode == goalNode) {
                goalReached = true;
                trackThePath();
            }
            step++;
        }
        return goalReached;
    }
}
```

#### 4.1.2 節點資料結構
```java
public class Node {
    Node parent;
    public int col, row;
    int gCost, hCost, fCost;
    boolean solid;
    boolean open, checked;
    
    public Node(int col, int row) {
        this.col = col;
        this.row = row;
    }
}
```

### 4.2 碰撞檢測優化演算法

#### 4.2.1 空間分割
```java
public void checkNearbyEntities(Entity entity) {
    // 只檢查攝影機範圍內的實體
    int startCol = Math.max(0, (gp.player.worldX - gp.player.screenX) / gp.tileSize - 1);
    int endCol = Math.min(gp.maxWorldCol, startCol + gp.maxScreenCol + 2);
    int startRow = Math.max(0, (gp.player.worldY - gp.player.screenY) / gp.tileSize - 1);
    int endRow = Math.min(gp.maxWorldRow, startRow + gp.maxScreenRow + 2);
    
    for(int col = startCol; col < endCol; col++) {
        for(int row = startRow; row < endRow; row++) {
            // 只檢查這個範圍內的碰撞
        }
    }
}
```

### 4.3 渲染優化演算法

#### 4.3.1 視錐剔除 (Frustum Culling)
```java
public void draw(Graphics2D g2) {
    // 計算攝影機可見範圍
    int worldCol = 0;
    int worldRow = 0;
    
    while(worldCol < gp.maxWorldCol && worldRow < gp.maxWorldRow) {
        int tileNum = mapTileNum[gp.currentMap][worldCol][worldRow];
        
        int worldX = worldCol * gp.tileSize;
        int worldY = worldRow * gp.tileSize;
        int screenX = worldX - gp.player.worldX + gp.player.screenX;
        int screenY = worldY - gp.player.worldY + gp.player.screenY;
        
        // 只渲染螢幕範圍內的瓦片
        if(worldX + gp.tileSize > gp.player.worldX - gp.player.screenX &&
           worldX - gp.tileSize < gp.player.worldX + gp.player.screenX &&
           worldY + gp.tileSize > gp.player.worldY - gp.player.screenY &&
           worldY - gp.tileSize < gp.player.worldY + gp.player.screenY) {
            
            g2.drawImage(tile[tileNum].image, screenX, screenY, null);
        }
        
        worldCol++;
        if(worldCol == gp.maxWorldCol) {
            worldCol = 0;
            worldRow++;
        }
    }
}
```

## 5. 記憶體管理

### 5.1 資源管理策略

#### 5.1.1 圖像資源管理
```java
public class ImageManager {
    private static Map<String, BufferedImage> imageCache = new HashMap<>();
    
    public static BufferedImage getImage(String path) {
        if(!imageCache.containsKey(path)) {
            try {
                BufferedImage image = ImageIO.read(ImageManager.class.getResourceAsStream(path));
                imageCache.put(path, image);
            } catch(IOException e) {
                e.printStackTrace();
            }
        }
        return imageCache.get(path);
    }
    
    public static void clearCache() {
        imageCache.clear();
    }
}
```

#### 5.1.2 物件池模式
```java
public class ProjectilePool {
    private Queue<Projectile> pool = new LinkedList<>();
    private int maxSize = 50;
    
    public Projectile getProjectile() {
        if(pool.isEmpty()) {
            return new Projectile();
        } else {
            return pool.poll();
        }
    }
    
    public void returnProjectile(Projectile projectile) {
        if(pool.size() < maxSize) {
            projectile.reset();
            pool.offer(projectile);
        }
    }
}
```

### 5.2 垃圾回收優化

#### 5.2.1 避免頻繁物件創建
```java
// 避免在遊戲循環中創建新物件
// 錯誤做法:
public void update() {
    Rectangle rect = new Rectangle(x, y, width, height); // 每幀創建新物件
}

// 正確做法:
private Rectangle tempRect = new Rectangle(); // 重用物件
public void update() {
    tempRect.setBounds(x, y, width, height);
}
```

#### 5.2.2 字串處理優化
```java
// 使用StringBuilder避免字串連接產生的垃圾
StringBuilder sb = new StringBuilder();
sb.append("Player Level: ").append(level);
sb.append(" HP: ").append(life).append("/").append(maxLife);
String statusText = sb.toString();
```

## 6. 效能優化策略

### 6.1 渲染效能優化

#### 6.1.1 批次渲染
```java
public void drawEntities(Graphics2D g2) {
    // 將所有實體加入列表並排序
    entityList.clear();
    
    // 加入玩家
    entityList.add(gp.player);
    
    // 加入NPC和怪物
    for(int i = 0; i < gp.npc[1].length; i++) {
        if(gp.npc[gp.currentMap][i] != null) {
            entityList.add(gp.npc[gp.currentMap][i]);
        }
    }
    
    // 按Y座標排序 (實現深度效果)
    Collections.sort(entityList, new Comparator<Entity>() {
        @Override
        public int compare(Entity e1, Entity e2) {
            int result = Integer.compare(e1.worldY, e2.worldY);
            return result;
        }
    });
    
    // 批次繪製
    for(Entity entity : entityList) {
        entity.draw(g2);
    }
}
```

#### 6.1.2 LOD (Level of Detail)
```java
public void draw(Graphics2D g2) {
    int screenX = worldX - gp.player.worldX + gp.player.screenX;
    int screenY = worldY - gp.player.worldY + gp.player.screenY;
    
    // 距離玩家太遠的實體使用簡化渲染
    int distance = Math.abs(gp.player.worldX - worldX) + Math.abs(gp.player.worldY - worldY);
    
    if(distance > gp.tileSize * 10) {
        // 遠距離：只繪製簡單形狀
        g2.fillRect(screenX, screenY, gp.tileSize, gp.tileSize);
    } else {
        // 近距離：繪製完整精靈
        g2.drawImage(image, screenX, screenY, null);
    }
}
```

### 6.2 邏輯效能優化

#### 6.2.1 更新頻率控制
```java
public void update() {
    // 不是每幀都需要更新的邏輯
    actionLockCounter++;
    
    if(actionLockCounter % 30 == 0) { // 每半秒更新一次
        // AI決策邏輯
        setAction();
    }
    
    if(actionLockCounter % 60 == 0) { // 每秒更新一次
        // 生命恢復邏輯
        regenerateHealth();
    }
}
```

#### 6.2.2 早期退出優化
```java
public void checkCollision() {
    // 如果實體沒有移動，跳過碰撞檢測
    if(speed == 0) return;
    
    // 如果實體在螢幕外，跳過詳細檢測
    if(!isOnScreen()) return;
    
    // 執行碰撞檢測
    collisionOn = false;
    gp.cChecker.checkTile(this);
    gp.cChecker.checkObject(this, false);
    gp.cChecker.checkEntity(this, gp.npc);
}
```

## 7. 錯誤處理與除錯

### 7.1 異常處理策略

#### 7.1.1 資源載入異常處理
```java
public BufferedImage loadImage(String path) {
    BufferedImage image = null;
    try {
        image = ImageIO.read(getClass().getResourceAsStream(path));
    } catch(IOException e) {
        System.err.println("無法載入圖像: " + path);
        e.printStackTrace();
        
        // 載入預設圖像
        image = createDefaultImage();
    }
    return image;
}

private BufferedImage createDefaultImage() {
    BufferedImage defaultImage = new BufferedImage(gp.tileSize, gp.tileSize, BufferedImage.TYPE_INT_RGB);
    Graphics2D g2 = defaultImage.createGraphics();
    g2.setColor(Color.MAGENTA); // 明顯的錯誤顏色
    g2.fillRect(0, 0, gp.tileSize, gp.tileSize);
    g2.dispose();
    return defaultImage;
}
```

#### 7.1.2 存檔系統異常處理
```java
public void saveGame() {
    try {
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(dataFile));
        DataStorage ds = new DataStorage();
        
        // 保存資料
        ds.level = gp.player.level;
        ds.life = gp.player.life;
        // ... 其他資料
        
        oos.writeObject(ds);
        oos.close();
        
    } catch(Exception e) {
        System.err.println("存檔失敗: " + e.getMessage());
        e.printStackTrace();
        
        // 顯示錯誤訊息給玩家
        gp.ui.showMessage("存檔失敗！請檢查磁碟空間。");
    }
}
```

### 7.2 除錯工具

#### 7.2.1 除錯模式
```java
public class DebugMode {
    public static boolean DEBUG_MODE = false;
    public static boolean SHOW_COLLISION_BOXES = false;
    public static boolean SHOW_FPS = false;
    public static boolean GOD_MODE = false;
    
    public static void drawDebugInfo(Graphics2D g2, GamePanel gp) {
        if(!DEBUG_MODE) return;
        
        g2.setColor(Color.WHITE);
        g2.setFont(new Font("Arial", Font.PLAIN, 12));
        
        if(SHOW_FPS) {
            g2.drawString("FPS: " + gp.currentFPS, 10, 20);
        }
        
        if(SHOW_COLLISION_BOXES) {
            drawCollisionBoxes(g2, gp);
        }
        
        // 顯示玩家座標
        g2.drawString("Player: (" + gp.player.worldX + ", " + gp.player.worldY + ")", 10, 40);
    }
    
    private static void drawCollisionBoxes(Graphics2D g2, GamePanel gp) {
        g2.setColor(Color.RED);
        g2.setStroke(new BasicStroke(1));
        
        // 繪製玩家碰撞框
        int screenX = gp.player.worldX - gp.player.worldX + gp.player.screenX;
        int screenY = gp.player.worldY - gp.player.worldY + gp.player.screenY;
        g2.drawRect(screenX + gp.player.solidArea.x, 
                   screenY + gp.player.solidArea.y,
                   gp.player.solidArea.width, 
                   gp.player.solidArea.height);
    }
}
```

#### 7.2.2 效能監控
```java
public class PerformanceMonitor {
    private long frameStartTime;
    private long updateTime;
    private long renderTime;
    private int frameCount;
    private long lastSecond;
    
    public void startFrame() {
        frameStartTime = System.nanoTime();
    }
    
    public void endUpdate() {
        updateTime = System.nanoTime() - frameStartTime;
    }
    
    public void endRender() {
        renderTime = System.nanoTime() - frameStartTime - updateTime;
        frameCount++;
        
        long currentTime = System.currentTimeMillis();
        if(currentTime - lastSecond >= 1000) {
            System.out.println("FPS: " + frameCount + 
                             " Update: " + (updateTime / 1000000) + "ms" +
                             " Render: " + (renderTime / 1000000) + "ms");
            frameCount = 0;
            lastSecond = currentTime;
        }
    }
}
```

## 8. 部署與建置

### 8.1 Gradle建置配置

#### 8.1.1 build.gradle設定
```gradle
plugins {
    id 'java'
    id 'application'
}

version = '2.16.0'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // 目前無外部依賴
}

application {
    mainClassName = 'gtcafe.rpg.Main'
}

jar {
    manifest {
        attributes(
            'Main-Class': 'gtcafe.rpg.Main'
        )
    }
    from {
        configurations.runtimeClasspath.collect { 
            it.isDirectory() ? it : zipTree(it) 
        }
    }
}

// 建立可執行JAR
task fatJar(type: Jar) {
    manifest {
        attributes 'Main-Class': 'gtcafe.rpg.Main'
    }
    archiveBaseName = 'ma-legend'
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
    with jar
}
```

### 8.2 資源打包策略

#### 8.2.1 資源結構
```
src/main/resources/
└── gtcafe/rpg/assets/
    ├── bgm/           # 背景音樂
    ├── sound/         # 音效檔案
    ├── player/        # 玩家精靈圖
    ├── monster/       # 怪物精靈圖
    ├── npc/          # NPC精靈圖
    ├── objects/      # 物件圖像
    ├── tilesV3/      # 地圖瓦片
    ├── maps_v2/      # 地圖資料檔
    └── font/         # 字體檔案
```

#### 8.2.2 資源壓縮
```java
// 圖像壓縮載入
public BufferedImage loadCompressedImage(String path) {
    try {
        BufferedImage original = ImageIO.read(getClass().getResourceAsStream(path));
        
        // 如果是大圖像，進行壓縮
        if(original.getWidth() > 512 || original.getHeight() > 512) {
            BufferedImage compressed = new BufferedImage(
                original.getWidth() / 2, 
                original.getHeight() / 2, 
                BufferedImage.TYPE_INT_RGB
            );
            
            Graphics2D g2 = compressed.createGraphics();
            g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, 
                               RenderingHints.VALUE_INTERPOLATION_BILINEAR);
            g2.drawImage(original, 0, 0, compressed.getWidth(), compressed.getHeight(), null);
            g2.dispose();
            
            return compressed;
        }
        
        return original;
    } catch(IOException e) {
        e.printStackTrace();
        return null;
    }
}
```

## 9. 測試策略

### 9.1 單元測試

#### 9.1.1 碰撞檢測測試
```java
@Test
public void testCollisionDetection() {
    GamePanel gp = new GamePanel();
    CollisionChecker checker = new CollisionChecker(gp);
    
    // 建立測試實體
    Entity testEntity = new Entity() {
        @Override
        public void update() {}
        @Override
        public void draw(Graphics2D g2) {}
    };
    
    testEntity.worldX = 100;
    testEntity.worldY = 100;
    testEntity.solidArea = new Rectangle(0, 0, 48, 48);
    
    // 測試瓦片碰撞
    checker.checkTile(testEntity);
    
    // 驗證結果
    assertFalse("實體不應該與空氣瓦片碰撞", testEntity.collisionOn);
}
```

#### 9.1.2 遊戲邏輯測試
```java
@Test
public void testPlayerLevelUp() {
    Player player = new Player(null, null);
    player.level = 1;
    player.exp = 0;
    player.nextLevelExp = 100;
    
    // 模擬獲得經驗值
    player.gainExp(150);
    
    // 驗證升級
    assertEquals("玩家應該升到2級", 2, player.level);
    assertEquals("剩餘經驗值應該是50", 50, player.exp);
}
```

### 9.2 整合測試

#### 9.2.1 存檔系統測試
```java
@Test
public void testSaveLoadSystem() {
    GamePanel gp = new GamePanel();
    SaveLoad saveLoad = new SaveLoad(gp, null);
    
    // 設定測試資料
    gp.player.level = 5;
    gp.player.life = 80;
    gp.player.worldX = 1000;
    gp.player.worldY = 2000;
    
    // 執行存檔
    saveLoad.save();
    
    // 重設玩家資料
    gp.player.level = 1;
    gp.player.life = 100;
    gp.player.worldX = 0;
    gp.player.worldY = 0;
    
    // 載入存檔
    saveLoad.load();
    
    // 驗證資料
    assertEquals("等級應該恢復為5", 5, gp.player.level);
    assertEquals("生命值應該恢復為80", 80, gp.player.life);
    assertEquals("X座標應該恢復為1000", 1000, gp.player.worldX);
    assertEquals("Y座標應該恢復為2000", 2000, gp.player.worldY);
}
```

### 9.3 效能測試

#### 9.3.1 幀率穩定性測試
```java
public class PerformanceTest {
    @Test
    public void testFrameRateStability() {
        GamePanel gp = new GamePanel();
        gp.setupGame();
        
        List<Long> frameTimes = new ArrayList<>();
        long startTime = System.nanoTime();
        
        // 執行1000幀
        for(int i = 0; i < 1000; i++) {
            long frameStart = System.nanoTime();
            gp.update();
            gp.repaint();
            long frameEnd = System.nanoTime();
            
            frameTimes.add(frameEnd - frameStart);
        }
        
        // 計算平均幀時間
        double avgFrameTime = frameTimes.stream()
            .mapToLong(Long::longValue)
            .average()
            .orElse(0.0);
        
        double avgFPS = 1_000_000_000.0 / avgFrameTime;
        
        // 驗證幀率穩定性
        assertTrue("平均FPS應該接近60", Math.abs(avgFPS - 60.0) < 5.0);
    }
}
```

## 10. 維護與擴展指南

### 10.1 程式碼維護

#### 10.1.1 程式碼規範
```java
// 命名規範
public class PlayerInventory {          // 類別：PascalCase
    private int maxCapacity;            // 變數：camelCase
    public static final int MAX_ITEMS = 20; // 常數：UPPER_SNAKE_CASE
    
    public void addItem(Item item) {    // 方法：camelCase
        // 方法實現
    }
}

// 註解規範
/**
 * 處理玩家與NPC的互動
 * @param npc 要互動的NPC物件
 * @param interactionType 互動類型 (TALK, TRADE, QUEST)
 * @return 互動是否成功
 */
public boolean interactWithNPC(NPC npc, InteractionType interactionType) {
    // 實現邏輯
}
```

#### 10.1.2 重構指南
```java
// 重構前：長方法
public void updatePlayer() {
    // 處理輸入 (20行程式碼)
    // 更新位置 (15行程式碼)  
    // 檢查碰撞 (25行程式碼)
    // 更新動畫 (10行程式碼)
    // 處理戰鬥 (30行程式碼)
}

// 重構後：拆分為小方法
public void updatePlayer() {
    handleInput();
    updatePosition();
    checkCollisions();
    updateAnimation();
    handleCombat();
}

private void handleInput() { /* 處理輸入邏輯 */ }
private void updatePosition() { /* 更新位置邏輯 */ }
private void checkCollisions() { /* 碰撞檢測邏輯 */ }
private void updateAnimation() { /* 動畫更新邏輯 */ }
private void handleCombat() { /* 戰鬥處理邏輯 */ }
```

### 10.2 功能擴展

#### 10.2.1 新增怪物類型
```java
// 1. 建立新的怪物類別
public class MON_Dragon extends Entity {
    public MON_Dragon(GamePanel gp) {
        super(gp);
        
        type = type_monster;
        name = "Dragon";
        defaultSpeed = 1;
        speed = defaultSpeed;
        maxLife = 200;
        life = maxLife;
        attack = 15;
        defense = 5;
        exp = 50;
        
        // 載入精靈圖像
        getImage();
    }
    
    public void getImage() {
        up1 = setup("/monster/dragon_up_1", gp.tileSize, gp.tileSize);
        up2 = setup("/monster/dragon_up_2", gp.tileSize, gp.tileSize);
        // ... 其他方向的圖像
    }
    
    public void setAction() {
        // 龍的特殊AI行為
        if(getTileDistance(gp.player) < 5) {
            // 近距離時噴火攻擊
            breathFire();
        } else {
            // 遠距離時飛行移動
            flyTowardsPlayer();
        }
    }
}

// 2. 在AssetSetter中加入新怪物
public void setMonster() {
    int mapNum = 0;
    int i = 0;
    
    // 在特定位置生成龍
    gp.monster[mapNum][i] = new MON_Dragon(gp);
    gp.monster[mapNum][i].worldX = gp.tileSize * 25;
    gp.monster[mapNum][i].worldY = gp.tileSize * 30;
    i++;
}
```

#### 10.2.2 新增遊戲機制
```java
// 新增魔法系統
public class MagicSystem {
    GamePanel gp;
    public ArrayList<Spell> knownSpells;
    
    public MagicSystem(GamePanel gp) {
        this.gp = gp;
        this.knownSpells = new ArrayList<>();
        initializeSpells();
    }
    
    public void castSpell(int spellIndex) {
        if(spellIndex < 0 || spellIndex >= knownSpells.size()) return;
        
        Spell spell = knownSpells.get(spellIndex);
        
        // 檢查魔力是否足夠
        if(gp.player.mana < spell.manaCost) {
            gp.ui.showMessage("魔力不足！");
            return;
        }
        
        // 消耗魔力
        gp.player.mana -= spell.manaCost;
        
        // 執行法術效果
        spell.cast(gp.player.worldX, gp.player.worldY, gp.player.direction);
    }
}

// 法術基礎類別
public abstract class Spell {
    public String name;
    public int manaCost;
    public int cooldown;
    public int damage;
    
    public abstract void cast(int x, int y, String direction);
}
```

### 10.3 效能優化擴展

#### 10.3.1 多執行緒優化
```java
public class ThreadedGamePanel extends GamePanel {
    private ExecutorService updateExecutor;
    private ExecutorService renderExecutor;
    
    public ThreadedGamePanel() {
        super();
        updateExecutor = Executors.newSingleThreadExecutor();
        renderExecutor = Executors.newSingleThreadExecutor();
    }
    
    @Override
    public void run() {
        double drawInterval = 1000000000/FPS;
        double delta = 0;
        long lastTime = System.nanoTime();
        
        while(gameThread != null) {
            long currentTime = System.nanoTime();
            delta += (currentTime - lastTime) / drawInterval;
            lastTime = currentTime;
            
            if(delta >= 1) {
                // 在不同執行緒中執行更新和渲染
                updateExecutor.submit(this::update);
                renderExecutor.submit(this::repaint);
                delta--;
            }
        }
    }
}
```

#### 10.3.2 記憶體池擴展
```java
public class EntityPool {
    private Map<Class<? extends Entity>, Queue<Entity>> pools;
    
    public EntityPool() {
        pools = new HashMap<>();
        initializePools();
    }
    
    private void initializePools() {
        // 為不同類型的實體建立物件池
        pools.put(Projectile.class, new LinkedList<>());
        pools.put(Particle.class, new LinkedList<>());
        pools.put(TemporaryEffect.class, new LinkedList<>());
    }
    
    @SuppressWarnings("unchecked")
    public <T extends Entity> T getEntity(Class<T> entityClass) {
        Queue<Entity> pool = pools.get(entityClass);
        
        if(pool != null && !pool.isEmpty()) {
            return (T) pool.poll();
        } else {
            try {
                return entityClass.getDeclaredConstructor().newInstance();
            } catch(Exception e) {
                e.printStackTrace();
                return null;
            }
        }
    }
    
    public void returnEntity(Entity entity) {
        Queue<Entity> pool = pools.get(entity.getClass());
        if(pool != null) {
            entity.reset(); // 重設實體狀態
            pool.offer(entity);
        }
    }
}
```

## 11. 結論

M/A Legend的技術設計展現了完整的2D遊戲開發架構，從底層的遊戲引擎到上層的遊戲邏輯，每個系統都經過精心設計。這個架構具有以下特點：

### 11.1 技術優勢
- **模組化設計**: 各系統職責明確，便於維護和擴展
- **效能優化**: 採用多種優化策略確保60 FPS穩定運行
- **跨平台相容**: 基於Java的跨平台解決方案
- **完整功能**: 涵蓋現代2D RPG遊戲的所有核心功能

### 11.2 學習價值
- **遊戲引擎開發**: 展示如何從零構建2D遊戲引擎
- **系統設計**: 良好的軟體架構設計實踐
- **演算法應用**: A*尋路、碰撞檢測等演算法的實際應用
- **效能優化**: 遊戲開發中的效能優化技巧

### 11.3 擴展潛力
這個架構為未來的功能擴展提供了良好的基礎，可以輕鬆加入：
- 更複雜的AI系統
- 網路多人遊戲功能
- 更豐富的視覺效果
- 模組化的內容編輯器

M/A Legend不僅是一款完整的遊戲，更是一個優秀的遊戲開發學習範例，展現了如何將理論知識轉化為實際的遊戲產品。